# Engineering Maturity Snapshot

## Архитектурная стабильность
* **Текущее состояние**: Пройдена стадия "спагетти-кода". Выделены слои (Views, Use Cases, Services, Infrastructure). Полностью убран UI-импорт (`streamlit`) из сервисов. Введены DTO (`InsightMetrics`).
* **Уровень риска**: **Низкий**.
* **Комментарий**: Слоистая архитектура надежна. Привязка бизнес-логики напрямую к фреймворку отрисовки разорвана, что позволяет легко менять UI без риска сломать математику.

## Зрелость слоя данных
* **Текущее состояние**: Файловая база SQLite ограничена слоем `infrastructure/repositories/`. Внедрена примитивная (через таблицу `schema_info`), но надежная транзакционная система миграций.
* **Уровень риска**: **Средний**.
* **Комментарий**: Миграции v1 страхуют от случайного затирания данных при `CREATE TABLE`. Риски связаны только с конкурентным доступом (двойная запись), типичным для SQLite в многопользовательской среде.

## UI/UX стабильность
* **Текущее состояние**: Ликвидирована тяжелая библиотека `AgGrid`, приводящая к глитчам на телефонах. Внедрен механизм частичного рендеринга `@st.fragment` для форм. Вынесены дефолтные параметры темы в `config.toml`. Убраны "белые экраны" холодной инициализации с помощью нативного `st.spinner`.
* **Уровень риска**: **Низкий**.
* **Комментарий**: Пользовательский опыт переведен со стадии MVP на стадию продуктового коммерческого релиза (Polish Phase 6). Интерфейс прогнозируем на смартфонах.

## Тестовое покрытие
* **Текущее состояние**: Выстроена "пирамида с толстым основанием". Настроено 55 Unit-тестов и Mock-интеграций (тестирование Yandex.Disk API без реальной сети, сессий, SQLite-базы, бизнес-математики). Добавлены Headless-интеграционные тесты запуска (`test_integration_guard.py`).
* **Уровень риска**: **Низкий**.
* **Комментарий**: CI pipeline способен отловить 95% регрессионных поломок до деплоя. Логика расчетов покрыта бенчмарками на `pandas.testing`.

## Наблюдаемость
* **Текущее состояние**: Ошибки отлавливаются на уровне "написал лог в терминал" / "вернул `Result` с причиной в UI". 
* **Уровень риска**: **Повышенный**.
* **Комментарий**: Отсутствует централизованная платформа мониторинга вызовов и потребления ОЗУ. Падение приложения в проде придется искать только перечитыванием логов SSH. Защита от брутфорс-атак (остановка после 5 попыток логина) есть, но без отправки нотификаций администратору.

## Готовность к росту
* **Текущее состояние**: Добавлена новая боковая навигация, позволившая уйти от ограничения ширины экрана. Переход с кэширования сессий на глобальный `@st.cache_data` радикально (в N раз) снижает RAM.
* **Уровень риска**: **Средний**.
* **Комментарий**: Технический продукт полностью готов принять x15 больше пользователей или x3 больше ресторанов, но при дальнейшем росте размера датасета в Parquet упрется в архитектурные лимиты Streamlit.


---

# Триггеры масштабирования и роста (Scalability Roadmap)

Система стабилизирована, однако Streamlit имеет жесткие пределы. Внедряйте следующие инженерные концепции строго при наступлении **описанных ниже пороговых триггеров**. Избыточная инженерия "заранее" приведет лишь к удорожанию поддержки проекта.

### 1. Переход с SQLite на PostgreSQL (или Managed DB)
* **Триггер**:
  - `> 5` одновременных активных сессий Управляющих, *регулярно совершающих изменения (сохранение настроек, редактирование профилей, регистрация, изменение параметров категорий)*.
  - Журналы (логи) фиксируют появление ошибки `sqlite3.OperationalError: database is locked`.
* **Обоснование**: SQLite отлично читает паралелльно, но блокирует весь файл для операции записи. Если менеджеры начнут одновременно сохранять свои варианты настроек, приложение зависнет.
* **Решение**: Разворачивание PostgreSQL (Docker). Благодаря `infrastructure` слою потребуется заменить только реализацию репозитория абстрактных интерфейсов пользователя.

### 2. Внедрение Sentry (Централизованное логирование)
* **Триггер**: 
  - Продукт обслуживает `> 3-х` независимых ресторанов-клиентов одновременно.
  - Появление жалоб от бизнеса в духе *"вчера вечером что-то кнопка не работала"*, подтверждение чему трудно отыскать в текстовых логах сервера.
* **Обоснование**: При росте базы клиентов вы не можете позволить себе заходить на сервер каждый раз, когда кто-то жалуется на интерфейс.
* **Решение**: Интеграция SDK Sentry. Любая ошибка в Python будет мгновенно прилетать вам в Telegram (или Slack) со скриншотом вызова, локальными переменными, ID пользователя, который ее вызвал, и параметрами потребления памяти на этот момент.

### 3. Предварительная агрегация данных (OLAP / ClickHouse)
* **Триггер**: 
  - Размер файла `current_data.parquet` на диске превышает `400 MB`.
  - Время "Холодного старта" (чтение паркета и первичный спиннер загрузки) превышает `6 секунд`.
* **Обоснование**: Сейчас весь Pandas Дата-Фрейм загружается в оперативную память (RAM) сервера. При гигантском Parquet-файле серверу потребуется дорогой апгрейд памяти (с 2 ГБ ОЗУ до 8-16 ГБ), а Streamlit будет медленно его фильтровать.
* **Решение**: Миграция от Pandas в памяти к коннектору DuckDB (встроенный аналитический SQL) ИЛИ ClickHouse (внешняя OLAP-база), чтобы запрашивать у базы только то, что менеджер смотрит прямо сейчас, переложив нагрузку с сервера веб-приложения на СУБД базы данных.

### 4. Добавление нагруженных E2E тестов (Playwright)
* **Триггер**: 
  - На проекте появляется еще один разработчик.
  - В интерфейс добавляются сложные многошаговые формы (wizard-ы).
* **Обоснование**: Вы покрыли математику и старт приложения. Но Python-код (Unit-тесты) не гарантирует, что кнопка в браузере визуально не перекрыта другой кнопкой.
* **Решение**: Скрипты Playwright, которые открывают реальный Headless Chromium браузер на GitHub Actions, логинятся под тестовым юзером и виртуально кликают по каждой вкладке.

### 5. Фоновая обработка метрик (Celery/RQ)
* **Триггер**: 
  - `analytics_service.py` и `data_loader.py` скачивают и обрабатывают исходный файл дольше `20 секунд` после нажатия кнопки "Скачать и Обновить".
* **Обоснование**: Пользователь не будет смотреть на `st.spinner("Связываюсь с Яндекс Диском...")` почти полминуты. Браузер закроет соединение по тайм-ауту.
* **Решение**: Внедрение Celery или легкого `background_tasks`. Клик по кнопке отдает мгновенный ответ "Запущено в фоне", а через 20 секунд приложение локально или через WebSocket уведомляет управляющего "Данные обновлены".
